#[repr(C)]
#[derive(Debug, PartialEq, Eq, Hash)]
// This sadly cannot be marked as #[non_exhaustive] as the struct construction
// has to be possible in a static context.
#[doc(hidden)]
pub struct Lint {
    /// A string identifier for the lint.
    ///
    /// This identifies the lint in attributes and in command-line arguments.
    /// In those contexts it is always lowercase. This allows
    /// [`declare_lint!`] macro invocations to follow the convention of upper-case
    /// statics without repeating the name.
    ///
    /// The name is written with underscores, e.g., "unused_imports".
    /// On the command line, underscores become dashes.
    ///
    /// See <https://rustc-dev-guide.rust-lang.org/diagnostics.html#lint-naming>
    /// for naming guidelines.
    ///
    /// [`declare_lint!`]: declare_lint
    pub name: &'static str,

    /// Default level for the lint.
    ///
    /// See <https://rustc-dev-guide.rust-lang.org/diagnostics.html#diagnostic-levels>
    /// for guidelines on choosing a default level.
    pub default_level: Level,

    /// Description of the lint or the issue it detects.
    ///
    /// e.g., "imports that are never used"
    pub explanation: &'static str,

    /// The level of macro reporting.
    ///
    /// See [`MacroReport`] for the possible levels.
    pub report_in_macro: MacroReport,
    // FIXME: We might want to add more fields. This should be possible as this
    // struct is always constructed by a macro controlled by marker. These are some
    // additional fields used  in rustc:
    // * pub edition_lint_opts: Option<(Edition, Level)>,
    // * pub future_incompatible: Option<FutureIncompatibleInfo>,
    // * pub feature_gate: Option<&'static str>,
    // * pub crate_level_only: bool,
}

/// FIXME(xFrednet): These settings should be working now, but are still limited
/// due to the limited [`Span`](crate::ast::Span) implementation. Ideally, I would
/// also like more options, like a `Local` variant that only lints in local marcos.
/// For libraries it might also be cool to have a `Crate` variant, that only lints
/// in user code and code from macros from the specified crate.
///
/// See: rust-marker/marker#149
#[repr(C)]
#[non_exhaustive]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MacroReport {
    /// No reporting in local or external macros.
    No,
    /// Report in local and external macros.
    All,
}

/// Setting for how to handle a lint.
#[repr(C)]
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]
pub enum Level {
    /// The lint is allowed. A created diagnostic will not be emitted to the user by default.
    /// This level can be overridden. It's useful for rather strict lints.
    Allow,
    /// The `warn` level will produce a warning if the lint was violated, however the
    /// compiler will continue with its execution.
    ///
    /// This level might also be used in instances were the diagnostic is not emitted
    /// to the user but used internally. This can for instance happen for lint
    /// expectations (RFC 2383).
    Warn,
    /// The `deny` level will produce an error and stop further execution after the lint
    /// pass is complete.
    Deny,
    /// The `forbid` level will produce an error and cannot be overriden by the user.
    ///
    /// Choosing this diagnostic level should require heavy consideration, because should a lint
    /// with this level produce a false-positive, the user won't have an option to `allow` the lint
    /// for this particular case, and will be forced to either:
    /// - Write wrong code just to satisfy the lint
    /// - Remove the whole lint crate
    ///
    /// To produce an error, but make the lint possible to override see [`Deny`](`Self::Deny`).
    Forbid,
}

/// This macro creates a new lint instance. The doc comment of the lint will be
/// available in the crate documentation and any documentation generated by Marker.
/// The content will be rendered with Markdown.
///
/// It's recommended to include a section explaining what the lint does, and an
/// example. You can also provide additional information, like "limitations" or
/// "known problems". Here is a recommended template:
///
/// ```
/// marker_api::declare_lint!{
///     /// # What it does
///     /// Here you can describe what your lint does.
///     ///
///     /// # Example
///     /// ```
///     /// <bad example>
///     /// ```
///     ///
///     /// Use instead
///     /// ```
///     /// <bad example>
///     /// ```
///     ITEM_WITH_TEST_NAME,
///     Warn,
/// }
/// ```
#[macro_export]
macro_rules! declare_lint {
    (
        $(#[doc = $doc:literal])+
        $NAME: ident,
        $LEVEL: ident $(,)?
    ) => {
        $crate::declare_lint!{
            $(#[doc = $doc])+
            $NAME,
            $LEVEL,
            $crate::lint::MacroReport::No,
        }
    };
    (
        $(#[doc = $doc:literal])+
        $NAME: ident,
        $LEVEL: ident,
        $REPORT_IN_MACRO: expr $(,)?
    ) => {
        $(#[doc = $doc])+
        pub static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {
            name: concat!("marker::", stringify!($NAME)),
            default_level: $crate::lint::Level::$LEVEL,
            explanation: concat!($($doc, '\n',)*),
            report_in_macro: $REPORT_IN_MACRO,
        };
    };
}
